{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":["processFiles","processStream","processString"],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport * as ts from \"typescript\";\nimport formatter from \"./formatter\";\nimport {createDefaultFormatCodeOptions} from \"./utils\";\n\nimport * as fs from \"fs\";\n\nimport base from \"./provider/base\";\nimport tsconfigjson from \"./provider/tsconfigjson\";\nimport editorconfig from \"./provider/editorconfig\";\nimport tslintjson, {postProcess as tslintPostProcess} from \"./provider/tslintjson\";\n\nexport interface Options {\n    dryRun?: boolean;\n    verbose?: boolean;\n    baseDir?: string;\n    replace: boolean;\n    verify: boolean;\n    tsconfig: boolean;\n    tslint: boolean;\n    editorconfig: boolean;\n    tsfmt: boolean;\n}\n\nexport interface PostProcess {\n    (fileName: string, formattedCode: string, opts: Options, formatOptions: ts.FormatCodeOptions): string;\n}\n\nexport interface ResultMap {\n    [fileName: string]: Result;\n}\n\nexport interface Result {\n    fileName: string;\n    options: ts.FormatCodeOptions;\n    message: string;\n    error: boolean;\n    src: string;\n    dest: string;\n}\n\nexport function processFiles(files: string[], opts: Options): Promise<ResultMap> {\n    \"use strict\";\n\n    let resultMap: ResultMap = {};\n    let promises = files.map(fileName => {\n        if (!fs.existsSync(fileName)) {\n            let result: Result = {\n                fileName: fileName,\n                options: null,\n                message: `${fileName} does not exist. process abort.\\n`,\n                error: true,\n                src: \"\",\n                dest: \"\"\n            };\n            return Promise.resolve(result);\n        }\n\n        let content = fs.readFileSync(fileName).toString();\n        return processString(fileName, content, opts);\n    });\n    return Promise.all(promises).then(resultList=> {\n        resultList.forEach(result => {\n            resultMap[result.fileName] = result;\n        });\n        return resultMap;\n    });\n}\n\nexport function processStream(fileName: string, input: NodeJS.ReadableStream, opts: Options): Promise<Result> {\n    \"use strict\";\n\n    input.setEncoding(\"utf8\");\n\n    let promise = new Promise<string>((resolve, reject) => {\n        let fragment = \"\";\n        input.on(\"data\", (chunk: string) => {\n            fragment += chunk;\n        });\n\n        input.on(\"end\", () => {\n            resolve(fragment);\n        });\n    });\n    return promise.then(content => processString(fileName, content, opts));\n}\n\nexport function processString(fileName: string, content: string, opts: Options): Promise<Result> {\n    \"use strict\";\n\n    let formatOptions = createDefaultFormatCodeOptions();\n    let optGenPromises: (ts.FormatCodeOptions | Promise<ts.FormatCodeOptions>)[] = [];\n    let postProcesses: PostProcess[] = [];\n    if (opts.tsfmt) {\n        optGenPromises.push(base(fileName, opts, formatOptions));\n    }\n    if (opts.tsconfig) {\n        optGenPromises.push(tsconfigjson(fileName, opts, formatOptions));\n    }\n    if (opts.editorconfig) {\n        optGenPromises.push(editorconfig(fileName, opts, formatOptions));\n    }\n    if (opts.tslint) {\n        optGenPromises.push(tslintjson(fileName, opts, formatOptions));\n        postProcesses.push(tslintPostProcess);\n    }\n\n    return Promise\n        .all(optGenPromises)\n        .then(() => {\n            let formattedCode = formatter(fileName, content, formatOptions);\n            if ((<any>formattedCode).trimRight) {\n                formattedCode = (<any>formattedCode).trimRight();\n                formattedCode += formatOptions.NewLineCharacter;\n            }\n\n            postProcesses.forEach(postProcess => {\n                formattedCode = postProcess(fileName, formattedCode, opts, formatOptions) || formattedCode;\n            });\n\n            // replace newline code. maybe NewLineCharacter params affect to only \"new\" newline by language service.\n            formattedCode = formattedCode.replace(/\\r?\\n/g, formatOptions.NewLineCharacter);\n\n            let message: string;\n            let error = false;\n            if (opts && opts.verify) {\n                if (content !== formattedCode) {\n                    message = `${fileName} is not formatted\\n`;\n                    error = true;\n                }\n            } else if (opts && opts.replace) {\n                if (content !== formattedCode) {\n                    fs.writeFileSync(fileName, formattedCode);\n                    message = `replaced ${fileName}\\n`;\n                }\n            } else if (opts && !opts.dryRun) {\n                message = formattedCode;\n            }\n\n            let result: Result = {\n                fileName: fileName,\n                options: formatOptions,\n                message: message,\n                error: error,\n                src: content,\n                dest: formattedCode\n            };\n            return Promise.resolve(result);\n        });\n}\n"]}