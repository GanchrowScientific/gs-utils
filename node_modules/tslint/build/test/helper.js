var fs = require("fs");
var path = require("path");
var Lint = require("./lint");
function getSourceFile(fileName) {
    var relativePath = path.join("test", "files", fileName);
    var source = fs.readFileSync(relativePath, "utf8");
    return Lint.getSourceFile(fileName, source);
}
exports.getSourceFile = getSourceFile;
function getRule(ruleName) {
    var rulesDirectory = path.join(path.dirname(module.filename), "../src/rules");
    return Lint.findRule(ruleName, rulesDirectory);
}
exports.getRule = getRule;
function getFormatter(formatterName) {
    var formattersDirectory = path.join(path.dirname(module.filename), "../src/formatters");
    return Lint.findFormatter(formatterName, formattersDirectory);
}
exports.getFormatter = getFormatter;
function applyRuleOnFile(fileName, Rule, ruleValue) {
    if (ruleValue === void 0) { ruleValue = true; }
    var sourceFile = getSourceFile(fileName);
    var rule = new Rule("", ruleValue, []);
    return rule.apply(sourceFile);
}
exports.applyRuleOnFile = applyRuleOnFile;
function createFailure(fileName, start, end, failure) {
    var sourceFile = getSourceFile(fileName);
    var startPosition = sourceFile.getPositionOfLineAndCharacter(start[0] - 1, start[1] - 1);
    var endPosition = sourceFile.getPositionOfLineAndCharacter(end[0] - 1, end[1] - 1);
    return new Lint.RuleFailure(sourceFile, startPosition, endPosition, failure, "");
}
exports.createFailure = createFailure;
function createFailuresOnFile(fileName, failure) {
    return function (start, end) {
        return createFailure(fileName, start, end, failure);
    };
}
exports.createFailuresOnFile = createFailuresOnFile;
function assertFailuresEqual(actualFailures, expectedFailures) {
    assert.equal(actualFailures.length, expectedFailures.length);
    actualFailures.forEach(function (actualFailure, i) {
        var startPosition = JSON.stringify(actualFailure.getStartPosition().toJson());
        var endPosition = JSON.stringify(actualFailure.getEndPosition().toJson());
        assert.isTrue(actualFailure.equals(expectedFailures[i]), "actual failure at " + startPosition + ", " + endPosition + " did not match expected failure");
    });
}
exports.assertFailuresEqual = assertFailuresEqual;
function assertContainsFailure(haystack, needle) {
    var haystackContainsNeedle = haystack.some(function (item) { return item.equals(needle); });
    if (!haystackContainsNeedle) {
        var stringifiedNeedle = JSON.stringify(needle.toJson(), null, 2);
        var stringifiedHaystack = JSON.stringify(haystack.map(function (hay) { return hay.toJson(); }), null, 2);
        assert(false, "expected " + stringifiedNeedle + " within " + stringifiedHaystack);
    }
}
exports.assertContainsFailure = assertContainsFailure;
